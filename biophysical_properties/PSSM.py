import sys

from numpy import dtype, float32
sys.path.append("../DeepDDG_reconstruction")

import os
import pandas as pd
import numpy as np
from scipy.special import softmax
from Bio.Blast.Applications import NcbipsiblastCommandline

class PSSM(object):
    """PSSSM stands for position-specific socring-matrix
    """
    def __init__(self, db=None) -> None:
        super().__init__()
        self.pssm_output_dir = "data/pssms/"
        self.psiblast_exe = "3rd_party_items/ncbi-blast-2.12.0+/bin/psiblast"
        self.db = "3rd_party_items/swissprot_db/swissprot" if db is None else db
        
        
    def set_db(self, db):
        self.db = db
        
        
    def set_up(self, fasta_file, force=False):
        """This blast run the query sequence 3 iterations against a db using psiblast program,
        and save the output file in pssms directory. 

        Args:
            fasta_file (str): file path
            force (bool): whether to enforce PSSM set up from start
        """
        pdbid = fasta_file.split("/")[2].split(".")[0]
        output_file_path = self.pssm_output_dir + pdbid +".pssm"
        
        if os.path.exists(output_file_path) and force==False: 
            print("PSSM is already set up for {}. To set-up again, set force=True".format(pdbid))
            return
        else:
            print("Computing PSSM for {} using psi-blast ... ...".format(pdbid))    
            E_VALUE_TRESH = "10"
            cline = NcbipsiblastCommandline(cmd=self.psiblast_exe, db=self.db, query=fasta_file,\
                                            evalue = E_VALUE_TRESH, outfmt = 5, num_iterations=3,\
                                            save_pssm_after_last_round=True, out_ascii_pssm=output_file_path)# 
                                            # out = out_xml, out_pssm=out_pssm, out_ascii_pssm=output_file_path)
            cline()
        
    
    def __parse_pssm_output_file(self, pssm_file):
        """Parse PSSM raw file generated by PSI-BLAST.

        Args:
            pssm_file (str): a pssm file path

        Returns:
            dataframe: raw result as dataframe
        """
        df = pd.read_csv(pssm_file, delim_whitespace=True, header=None, skiprows=[1, 2]) # skipping 1st 2 rows
        df = df.head(-5) # removing last 5 rows
        return df
    
   
    def of_a_residue(self, pssm_file, residue_index, type="softmax"):
        """Compute a PSSM for a given residue number.

        Args:
            pssm_file (str): a pssm file path
            residue_index (int): a residue number
            type (str, optional): If not softmax, it will return raw numpy array.
                Defaults to "softmax".

        Returns:
            nd array: 1x20 dimensional array 
        """
        df = self.__parse_pssm_output_file(pssm_file)
        pssm = np.array(df.loc[residue_index, 2:21], dtype=float32)
        if type=="softmax": pssm = softmax(pssm)
        return pssm
    
    
    def of_some_residues(self, pssm_file, from_residue=0, n_residues=None, type="softmax"):
        """Compute PSSM for a given residues.
        
        Args:
            pssm_file (str): a pssm file path
            from_residue (int, optional): Starting position. Defaults to 0.
            n_residues (int, optional): How many residues to process. Defaults to None.
                If n_residues is None, it will return the full PSSM.
            type (str, optional): If not softmax, it will return raw numpy array.
                Defaults to "softmax".

        Returns:
            nd array: n_residuesx20 dimensional array 
        """
        df = self.__parse_pssm_output_file(pssm_file)
        pssm = df.loc[:, 2:21] if n_residues is None else df.loc[from_residue:from_residue+n_residues-1, 2:21]
        pssm = np.array(pssm, dtype=float32)
        if type=="softmax": pssm = softmax(pssm, axis=1)
        return pssm
        

# fasta_file = "data/fastas/4eiuA.fasta"
# pssm_file = "data/pssms/4eiuA.pssm"

# sample usage
# pssm = PSSM()
# pssm.set_up(fasta_file)

# result = pssm.of_a_residue(pssm_file, 0) # check boundary value
# print(result)
# print(result.sum()) # 1
# result = pssm.of_a_residue(pssm_file, 241, type="softmax") # check boundary value

# result = pssm.of_some_residues(pssm_file, from_residue=0, n_residues=None, type="softmax") # getting pssm for all residues
# result = pssm.of_some_residues(pssm_file, from_residue=0, n_residues=5, type="softmax")
# print(result.shape)
# print(result.sum(axis=1)) # n_residues 1s 
# result = pssm.of_some_residues(pssm_file, from_residue=235, n_residues=100, type="softmax") # getting pssm upto last residue
